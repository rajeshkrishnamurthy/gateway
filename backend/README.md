## SMS REST contract

Gateway request (JSON):

```json
{
  "referenceId": "string",
  "to": "string",
  "message": "string",
  "tenantId": "string (optional)"
}
````

Gateway response (JSON):

```json
{
  "referenceId": "string",
  "status": "accepted|rejected",
  "gatewayMessageId": "string (present when accepted)",
  "reason": "invalid_request|duplicate_reference|invalid_recipient|invalid_message|provider_failure (present when rejected)"
}
```


## Push REST contract

Gateway request (JSON):

```json
{
  "referenceId": "string",
  "token": "string",
  "title": "string (optional)",
  "body": "string (optional)",
  "data": {"key": "value"} (optional),
  "tenantId": "string (optional)"
}
```

At least one of `title`, `body`, or `data` must be present.

Gateway response (JSON):

```json
{
  "referenceId": "string",
  "status": "accepted|rejected",
  "gatewayMessageId": "string (present when accepted)",
  "reason": "invalid_request|duplicate_reference|provider_failure (present when rejected)"
}
```

## HTTP status semantics

400
The request is invalid or a duplicate.
The client must change the request before retrying.

200 + status=rejected
Submission was attempted but not confirmed.
The client may retry later with the same or a new referenceId, based on its own policy.

200 + status=accepted
The request was successfully submitted to the provider.

## Submission vs delivery

An accepted response means the request was successfully submitted to the provider.

It does not guarantee:

* message delivery
* eventual delivery status
* retries on failure
* reconciliation

Delivery outcomes, if required, must be handled by systems outside the gateway.

## gatewayMessageId semantics

gatewayMessageId is generated by the gateway and is present only when status=accepted.
It represents confirmed submission, not delivery.
It must not be assumed to exist:
* when submission outcome is ambiguous
* when the provider fails or times out

## Idempotency

Gateway enforces idempotency only for concurrent in-flight requests within a single process using referenceId.
It does not guarantee idempotency across time, retries, or restarts, so a duplicate after a request completes may be accepted.

## Troubleshooting

Gateway troubleshooting is log-based.
Submission behavior can be reconstructed using the client-supplied referenceId.

## Metrics

Gateway exposes Prometheus metrics at `/metrics`.
Metrics are low-cardinality and use the adapter provider name for the `provider` label.
Latency histograms share buckets at 0.1s, 0.25s, 0.5s, 1s, 2.5s, and 5s.


## Gateway stack overview

The gateway stack is intentionally small and explicit:

- Gateways: `cmd/sms-gateway` and `cmd/push-gateway` are single-provider, submission-only processes. Provider semantics live in `config*.json`; bind address is supplied via `-addr`. Secrets are provided via environment variables only.
- HAProxy: optional load-balancer in `conf/haproxy.cfg` that fronts stable ports and routes to multiple gateway instances. Gateways remain unaware of peers.
- Prometheus: scrapes gateway instances directly using `conf/prometheus.yml` (do not scrape HAProxy). Jobs separate SMS vs push.
- Grafana: provisioned dashboards in `conf/grafana/dashboards`. The gateway UI Metrics link points to `GRAFANA_DASHBOARD_URL` (defaults to the SMS/push dashboard URLs).

## Prometheus quick start

Use the sample config at `conf/prometheus.yml` to scrape the gateway.

Start the gateway (adjust the config/port if needed):

```sh
go run ./cmd/sms-gateway -config conf/config.json -addr :8080
```

Start Prometheus with the sample config:

```sh
./prometheus --config.file=conf/prometheus.yml
```

Open the Prometheus UI at `http://localhost:9090` and run the query `gateway_requests_total`.
If you send a request through the gateway, the counter should increment.



## Services health console

The services health console is a standalone UI for checking gateway and tool status (up/down) and running start/stop commands defined in `conf/services_health.json`.

Start the console:

```sh
go run ./cmd/services-health -config conf/services_health.json -addr :8070
```

Open `http://localhost:8070/ui`.

Notes:
- Status checks use TCP connectivity to each configured `addr`.
- Start/stop actions execute the command arrays from the config with `{config}`, `{addr}`, and `{port}` placeholder substitution.
- Relative paths are resolved from the health console working directory.

## Grafana quick start

Grafana is optional and uses the existing Prometheus instance. Provisioning files live in `conf/grafana/`.

Start Grafana (Docker):

```sh
docker run --rm -p 3000:3000 \
  -v "$PWD/conf/grafana/provisioning:/etc/grafana/provisioning" \
  -v "$PWD/conf/grafana/dashboards:/var/lib/grafana/dashboards" \
  grafana/grafana:latest
```

Open `http://localhost:3000/d/gateway-overview-sms` for SMS and `http://localhost:3000/d/gateway-overview-push` for push.

Set `GRAFANA_DASHBOARD_URL` to point the gateway UI Metrics link at your Grafana instance.

## Load balancing (HAProxy)

HAProxy can provide a stable client endpoint while routing to multiple gateway instances. Gateways stay unchanged and run on distinct local ports.

Example (three SMS + three push instances):

```sh
# SMS gateways

go run ./cmd/sms-gateway -config conf/config.json -addr :18080

go run ./cmd/sms-gateway -config conf/config.json -addr :18081

go run ./cmd/sms-gateway -config conf/config.json -addr :18082

# Push gateways

go run ./cmd/push-gateway -config conf/config_push.json -addr :19080

go run ./cmd/push-gateway -config conf/config_push.json -addr :19081

go run ./cmd/push-gateway -config conf/config_push.json -addr :19082
```

Start HAProxy (fronts stable ports `:8080` for SMS and `:8081` for push):

```sh
haproxy -f conf/haproxy.cfg
```

Prometheus should scrape the gateway instances directly, not HAProxy. Update `conf/prometheus.yml` targets and reload Prometheus after scaling.

## Local fake provider + gateway smoke test

Start the fake provider:

```sh
go run ./cmd/fake-provider/fakeprovider -addr :9090
```

Gateway loads its configuration from `config.json` in the working directory:

```json
{
  "smsProvider": "default",
  "smsProviderUrl": "http://localhost:9090/sms/send",
  "smsProviderConnectTimeoutSeconds": 2,
  "smsProviderTimeoutSeconds": 30
}
```

Start the gateway:

```sh
go run ./cmd/sms-gateway -addr :8080
```

Send requests through the gateway (use a fresh referenceId each time):

```sh
curl -i -X POST http://localhost:8080/sms/send \
  -H 'Content-Type: application/json' \
  -d '{"referenceId":"ref-1","to":"15551234567","message":"hello"}'

curl -i -X POST http://localhost:8080/sms/send \
  -H 'Content-Type: application/json' \
  -d '{"referenceId":"ref-2","to":"abc","message":"hello"}'

curl -i -X POST http://localhost:8080/sms/send \
  -H 'Content-Type: application/json' \
  -d '{"referenceId":"ref-3","to":"15551234567","message":"                     "}'

curl -i -X POST http://localhost:8080/sms/send \
  -H 'Content-Type: application/json' \
  -d '{"referenceId":"ref-4FAIL","to":"15551234567","message":"hello"}'
```

## Model provider (adapter demo)

Start the model provider:

```sh
go run ./cmd/fake-provider/modelprovider -addr :9091
```

Note: the model provider intentionally adds a random 50msâ€“2s delay for manual latency testing (TODO: remove).

Configure the gateway to use it:

```json
{
  "smsProvider": "model",
  "smsProviderUrl": "http://localhost:9091/sms/send",
  "smsProviderConnectTimeoutSeconds": 2,
  "smsProviderTimeoutSeconds": 30
}
```

## sms24x7 provider

Set the API key via `SMS24X7_API_KEY` in the environment (do not put secrets in `config.json`).

```json
{
  "smsProvider": "sms24x7",
  "smsProviderUrl": "https://api.example.com/sms/send",
  "smsProviderServiceName": "your-service",
  "smsProviderSenderId": "your-sender",
  "smsProviderConnectTimeoutSeconds": 2,
  "smsProviderTimeoutSeconds": 30
}
```

## smskarix provider

Set the API key via `SMSKARIX_API_KEY` in the environment (do not put secrets in `config.json`).

```json
{
  "smsProvider": "smskarix",
  "smsProviderUrl": "https://api.example.com/sms/send",
  "smsProviderVersion": "v1",
  "smsProviderSenderId": "your-sender",
  "smsProviderConnectTimeoutSeconds": 2,
  "smsProviderTimeoutSeconds": 30
}
```

## smsinfobip provider

Set the API key via `SMSINFOBIP_API_KEY` in the environment (do not put secrets in `config.json`).

```json
{
  "smsProvider": "smsinfobip",
  "smsProviderUrl": "https://api.example.com/sms/send",
  "smsProviderSenderId": "your-sender",
  "smsProviderConnectTimeoutSeconds": 2,
  "smsProviderTimeoutSeconds": 30
}
```

## push gateway (FCM)

Set `PUSH_FCM_CREDENTIAL_JSON_PATH` (preferred) or `PUSH_FCM_BEARER_TOKEN` in the environment (do not put secrets in `config.json`). Optional: `PUSH_FCM_SCOPE_URL` overrides the default scope.

```json
{
  "pushProvider": "fcm",
  "pushProviderUrl": "https://fcm.googleapis.com/v1/projects/enc-scb/messages:send",
  "pushProviderConnectTimeoutSeconds": 2,
  "pushProviderTimeoutSeconds": 30
}
```

Start the push gateway:

```sh
go run ./cmd/push-gateway -config conf/config_push.json -addr :8081
```



Final note
Gateway is a real-time submission bridge.
It guarantees truthful submission outcomes and nothing beyond that.
Any capability beyond submission (delivery tracking, retries, reconciliation)
requires a separate system with explicit time ownership.

```
